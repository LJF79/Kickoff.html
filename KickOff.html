<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>PokerStars Kick-Off Assistant ‚Äì Stufe 3 (OCR + Empfehlung)</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<style>
*{box-sizing:border-box}
body{margin:0;background:#0b0f14;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
header{padding:12px 16px;background:#0f1520;border-bottom:1px solid #1c2733}
h1{margin:0;font-size:18px}
.controls{display:flex;flex-wrap:wrap;gap:8px;padding:10px 16px;background:#0f1520;border-bottom:1px solid #1c2733;align-items:center}
button{padding:10px 12px;border-radius:10px;border:1px solid #2d3d53;background:#0c121a;color:#e6edf3}
label.switch{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid #2d3d53;border-radius:10px;background:#0c121a}
.badge{display:inline-block;margin-left:8px;padding:4px 8px;border-radius:8px;border:1px solid #2d3d53;background:#111725}
.on{background:#16361e;border-color:#2f6c38}
.wrap{padding:12px 16px}
.videoWrap{position:relative;max-width:540px;margin:0 auto;border:1px solid #1c2733;border-radius:12px;overflow:hidden}
#video,#overlay{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block}
.row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.card{flex:1 1 160px;border:1px solid #223044;background:#0c121a;border-radius:10px;padding:10px}
.kpi{font-size:20px}
.rec{font-size:22px;font-weight:700;margin-top:6px}
.small{color:#94a3b8;font-size:13px}
pre{background:#0c121a;border:1px solid #223044;border-radius:10px;padding:10px;color:#cbd5e1;white-space:pre-wrap}
</style>
</head>
<body>
<header><h1>PokerStars Kick-Off Assistant ‚Äì OCR + Empfehlung</h1></header>

<div class="controls">
  <button id="btnCam">üì∑ Kamera starten</button>
  <button id="btnCal">üìê Kalibrierung</button>
  <button id="btnAuto">üß≤ Auto-Position</button>
  <button id="btnNext">üîÅ Box wechseln</button>
  <button id="btnReset">‚ôªÔ∏è Reset</button>
  <label class="switch"><input id="bountyToggle" type="checkbox"> Bounty</label>
  <label class="switch"><input id="forceTurn" type="checkbox"> Turn erzwingen</label>
  <span id="calState" class="badge">Calib: OFF</span>
</div>

<div class="wrap">
  <div class="videoWrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="row">
    <div class="card"><div>Turn:</div><div id="sTurn" class="kpi">‚Äì</div></div>
    <div class="card"><div>Hero-Karten:</div><div id="sCards" class="kpi">‚Äì</div></div>
    <div class="card"><div>Blinds / Hero-Stack:</div><div id="sSB" class="kpi">‚Äì</div></div>
    <div class="card"><div>Eff. Stack (BB):</div><div id="sEff" class="kpi">‚Äì</div></div>
  </div>

  <div class="card">
    <div>Empfehlung:</div>
    <div id="sRec" class="rec">‚Äì</div>
    <div id="sExp" class="small"></div>
  </div>

  <div class="card">
    <div><b>OCR-Debug</b></div>
    <div class="small">Buttons:</div><pre id="dbgButtons">‚Äì</pre>
    <div class="small">Blinds:</div><pre id="dbgBlinds">‚Äì</pre>
    <div class="small">Hero-Stack:</div><pre id="dbgStackH">‚Äì</pre>
    <div class="small">G1-Stack (links):</div><pre id="dbgStack1">‚Äì</pre>
    <div class="small">G2-Stack (oben):</div><pre id="dbgStack2">‚Äì</pre>
    <div class="small">G3-Stack (rechts):</div><pre id="dbgStack3">‚Äì</pre>
    <div class="small">C1:</div><pre id="dbgC1">‚Äì</pre>
    <div class="small">C2:</div><pre id="dbgC2">‚Äì</pre>
  </div>

  <p class="small">Kalibrierung: <b>C1/C2</b> auf deine Hole Cards, <b>stackH</b> auf deinen Chipwert, <b>blinds</b> auf ‚ÄûSB/BB‚Äú, <b>buttons</b> √ºber die ganze Leiste (Fold/Call/Raise). <b>g1‚Äìg3</b> auf Gegner-Stacks (links/oben/rechts).</p>
</div>

<script>
/* ---------- DOM ---------- */
const video=document.getElementById('video');
const overlay=document.getElementById('overlay');
const ctx=overlay.getContext('2d');

const btnCam=document.getElementById('btnCam');
const btnCal=document.getElementById('btnCal');
const btnAuto=document.getElementById('btnAuto');
const btnNext=document.getElementById('btnNext');
const btnReset=document.getElementById('btnReset');
const bountyToggle=document.getElementById('bountyToggle');
const forceTurn=document.getElementById('forceTurn');
const badge=document.getElementById('calState');

const sTurn=document.getElementById('sTurn'), sCards=document.getElementById('sCards');
const sSB=document.getElementById('sSB'), sEff=document.getElementById('sEff');
const sRec=document.getElementById('sRec'), sExp=document.getElementById('sExp');
const dbgButtons=document.getElementById('dbgButtons'), dbgBlinds=document.getElementById('dbgBlinds');
const dbgStackH=document.getElementById('dbgStackH'), dbgStack1=document.getElementById('dbgStack1');
const dbgStack2=document.getElementById('dbgStack2'), dbgStack3=document.getElementById('dbgStack3');
const dbgC1=document.getElementById('dbgC1'), dbgC2=document.getElementById('dbgC2');

/* ---------- State ---------- */
let stream=null, calib=false, activeKey='card1';
let running=false, lastTick=0;

const ROIS=[
 {key:'card1',label:'CARD 1'},
 {key:'card2',label:'CARD 2'},
 {key:'stackH',label:'Hero-Stack'},
 {key:'blinds',label:'Blinds'},
 {key:'buttons',label:'Buttons'},
 {key:'g1',label:'Gegner 1 (links)'},
 {key:'g2',label:'Gegner 2 (oben)'},
 {key:'g3',label:'Gegner 3 (rechts)'}
];
let rects={};

/* ---------- Layout / Draw ---------- */
function save(){localStorage.setItem('kickoff_rois_v3',JSON.stringify(rects));}
function load(){try{rects=JSON.parse(localStorage.getItem('kickoff_rois_v3')||'{}');}catch(e){rects={};}}
function resize(){overlay.width=overlay.clientWidth;overlay.height=overlay.clientHeight;draw();}
new ResizeObserver(resize).observe(document.querySelector('.videoWrap'));

function draw(){
 ctx.clearRect(0,0,overlay.width,overlay.height);
 if(!calib)return;
 for(const {key,label} of ROIS){
   const r=rects[key]; if(!r) continue;
   ctx.strokeStyle=(key===activeKey)?'#79d2ff':'#6aa3ff';
   ctx.lineWidth=(key===activeKey)?3:2;
   ctx.setLineDash([6,6]); ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.setLineDash([]);
   ctx.fillStyle='rgba(106,163,255,.08)'; ctx.fillRect(r.x,r.y,r.w,r.h);
   ctx.fillStyle='#e6edf3'; ctx.font='12px system-ui';
   ctx.fillText(label+(key===activeKey?' (active)':''), r.x+6, Math.max(12,r.y-6));
 }
}
function ensure(k){ if(!rects[k]) rects[k]={x:50,y:50,w:160,h:90}; }
function autoROIs(){
 const W=overlay.width||540, H=overlay.height||960; // vertikal
 rects.card1  ={x:W*0.40,y:H*0.70,w:W*0.20,h:H*0.08};
 rects.card2  ={x:W*0.60,y:H*0.70,w:W*0.20,h:H*0.08};
 rects.stackH ={x:W*0.50,y:H*0.82,w:W*0.28,h:H*0.07};
 rects.buttons={x:W*0.10,y:H*0.88,w:W*0.80,h:H*0.10};
 rects.blinds ={x:W*0.30,y:H*0.05,w:W*0.40,h:H*0.07};
 rects.g1     ={x:W*0.04,y:H*0.26,w:W*0.28,h:H*0.07};
 rects.g2     ={x:W*0.36,y:H*0.17,w:W*0.28,h:H*0.07};
 rects.g3     ={x:W*0.68,y:H*0.26,w:W*0.28,h:H*0.07};
 activeKey='card1'; save(); draw();
}
function nextBox(){
 const keys=ROIS.map(r=>r.key);
 activeKey=keys[(keys.indexOf(activeKey)+1)%keys.length];
 draw();
}
function resetBoxes(){ rects={}; save(); draw(); }

/* ---------- Interaktion (Touch/Maus) ---------- */
function getXY(ev){ const r=overlay.getBoundingClientRect(); const p=('touches'in ev?ev.touches[0]:ev);
 return {x:(p.clientX-r.left)*(overlay.width/r.width), y:(p.clientY-r.top)*(overlay.height/r.height)}; }
function hit(x,y,r){ return x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h; }
let dragging=false, dx=0, dy=0;
overlay.addEventListener('mousedown',e=>{ if(!calib)return; const {x,y}=getXY(e);
 const order=[activeKey,...ROIS.filter(r=>r.key!==activeKey).map(r=>r.key)];
 for(const k of order){ ensure(k); const R=rects[k]; if(hit(x,y,R)){ activeKey=k; dragging=true; dx=x-R.x; dy=y-R.y; draw(); break; } }});
overlay.addEventListener('mousemove',e=>{ if(!calib||!dragging)return; const {x,y}=getXY(e);
 const R=rects[activeKey]; R.x=Math.max(0,Math.min(overlay.width-R.w,x-dx)); R.y=Math.max(0,Math.min(overlay.height-R.h,y-dy)); draw(); });
overlay.addEventListener('mouseup',()=>{ dragging=false; save(); });
overlay.addEventListener('mouseleave',()=>{ dragging=false; });
overlay.addEventListener('touchstart',e=>{ if(!calib)return; const {x,y}=getXY(e);
 const order=[activeKey,...ROIS.filter(r=>r.key!==activeKey).map(r=>r.key)];
 for(const k of order){ ensure(k); const R=rects[k]; if(hit(x,y,R)){ activeKey=k; dragging=true; dx=x-R.x; dy=y-R.y; draw(); break; } }
 e.preventDefault(); },{passive:false});
overlay.addEventListener('touchmove',e=>{ if(!calib||!dragging)return; const {x,y}=getXY(e);
 const R=rects[activeKey]; R.x=Math.max(0,Math.min(overlay.width-R.w,x-dx)); R.y=Math.max(0,Math.min(overlay.height-R.h,y-dy)); draw(); e.preventDefault(); },{passive:false});
overlay.addEventListener('touchend',()=>{ dragging=false; save(); },{passive:false});

/* ---------- Kamera (lokal, ohne HTTPS-Zwang) ---------- */
btnCam.onclick=async()=>{ try{
 if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null;}
 const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
 video.srcObject=s; await video.play(); stream=s;
 document.querySelector('.videoWrap').style.aspectRatio=`${video.videoWidth||1080}/${video.videoHeight||1920}`;
 resize();
}catch(e){ alert('Kamera-Fehler: '+e.name+' ‚Äì '+e.message+'\nTipp: iOS > Einstellungen > Edge > Kamera > Erlauben.'); } };

/* ---------- Mapping Overlay ‚Üí Video (object-fit:cover) ---------- */
function computeVideoMapping(){
 const cw=overlay.clientWidth, ch=overlay.clientHeight;
 const vw=video.videoWidth||1080, vh=video.videoHeight||1920;
 const scale=Math.max(cw/vw, ch/vh); const dispW=vw*scale, dispH=vh*scale;
 const offX=(dispW-cw)/2, offY=(dispH-ch)/2; return {scale,offX,offY};
}
function mapToVideoRect(r){
 const {scale,offX,offY}=computeVideoMapping();
 return {sx:(r.x+offX)/scale, sy:(r.y+offY)/scale, sw:r.w/scale, sh:r.h/scale};
}

/* ---------- OCR & Parsing ---------- */
function logDbg(el, text){ el.textContent=(text||'').trim()||'‚Äì'; }
function preprocessFromVideoRect(vr){
 const src=document.createElement('canvas'); src.width=Math.max(1,Math.round(vr.sw)); src.height=Math.max(1,Math.round(vr.sh));
 const sctx=src.getContext('2d'); sctx.drawImage(video, vr.sx, vr.sy, vr.sw, vr.sh, 0,0, src.width, src.height);
 const up=2, dst=document.createElement('canvas'); dst.width=src.width*up; dst.height=src.height*up;
 const img=sctx.getImageData(0,0,src.width,src.height); const d=img.data;
 for(let i=0;i<d.length;i+=4){ const g=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; const c=(g-128)*1.3+128; const b=c>138?255:0; d[i]=d[i+1]=d[i+2]=b; d[i+3]=255; }
 sctx.putImageData(img,0,0); const dx=dst.getContext('2d'); dx.imageSmoothingEnabled=false; dx.drawImage(src,0,0,src.width,src.height,0,0,dst.width,dst.height);
 return dst;
}
async function ocrBox(r, psm='6'){
 if(!r) return {text:'',raw:''};
 const vr=mapToVideoRect(r); const proc=preprocessFromVideoRect(vr);
 const {data:{text}}=await Tesseract.recognize(proc,'eng+deu',{tessedit_pageseg_mode:psm});
 const norm=(text||'').replace(/\s+/g,' ').trim(); return {text:norm, raw:text||''};
}
function parseBlinds(txt){
 const clean=txt.replace(/BB/gi,'').replace(/:/g,'/').replace(/[|]/g,'/'); const m=clean.match(/(\d+(?:[.,]\d+)?)[^\d]+(\d+(?:[.,]\d+)?)/);
 if(!m) return null; const sb=parseFloat(m[1].replace(',','.')), bb=parseFloat(m[2].replace(',','.'));
 if(!isFinite(sb)||!isFinite(bb)||bb<=0) return null; return {sb,bb};
}
function parseStackAny(txt){
 const s=txt.toLowerCase().replace(/,/g,'.');
 const bb=s.match(/(\d+(?:\.\d+)?)\s*bb/); if(bb) return {mode:'bb',val:parseFloat(bb[1])};
 const km=s.match(/(\d+(?:\.\d+)?)(\s*[km])/); if(km){ let v=parseFloat(km[1]); const u=(km[2]||'').trim(); if(u==='k') v*=1e3; if(u==='m') v*=1e6; return {mode:'chips',val:v}; }
 const m=s.match(/(\d+(?:\.\d+)?)/); return m?{mode:'chips',val:parseFloat(m[1])}:null;
}
function parseCard(txt){ const m=txt.match(/([2-9TJQKA])\s*([hdsc])/i); return m? (m[1].toUpperCase()+m[2].toLowerCase()) : null; }
function combo(c1,c2){
 if(!c1||!c2) return null; const ord='23456789TJQKA'; let hi=c1,lo=c2;
 if(ord.indexOf(c1[0])<ord.indexOf(c2[0])){hi=c2;lo=c1;}
 if(hi[0]===lo[0]) return hi[0]+lo[0]; return hi[0]+lo[0]+(hi[1]===lo[1]?'s':'o');
}

/* ---------- Turn-Erkennung ---------- */
async function iAmOnTurn(){
 const r=rects.buttons; if(!r) return {turn:false, raw:''};
 const out=await ocrBox(r,'6'); const T=(out.text||'').toUpperCase();
 const KW=["CALL","CHECK","FOLD","RAISE","BET","ALL IN","ALL-IN","SETZEN","ERH√ñHEN","PASSEN","SCHIEBEN","CHECKEN","ALLES"];
 return {turn:KW.some(k=>T.includes(k)), raw:out.text};
}

/* ---------- Entscheidungs-Logik (vereinfachtes Open-Modell) ---------- */
const BASE_RANGES={
 "12":{"MP":["AJo","ATs","KQs","KJs","QJs","TT","JJ","QQ","KK","AA"],"LP":["A9s","ATo","KQo","KJs","QJs","JTs","T9s","77","88","99","TT","JJ","QQ","KK","AA"]},
 "20":{"MP":["AJo","ATo","ATs","KQs","KJs","QJs","88","99","TT","JJ","QQ","KK","AA"],"LP":["A8s","AJo","ATo","KQo","KJs","QJs","JTs","T9s","66","77","88","99","TT","JJ","QQ","KK","AA"]},
 "25":{"MP":["AJo","ATo","ATs","KQs","KJs","QJs","88","99","TT","JJ","QQ","KK","AA"],"LP":["A7s","AJo","ATo","KQo","KJs","QJs","JTs","T9s","55","66","77","88","99","TT","JJ","QQ","KK","AA"]},
 "40":{"MP":["AJo","ATo","ATs","KQs","KJs","QJs","88","99","TT","JJ","QQ","KK","AA"],"LP":["A5s","AJo","ATo","KQo","KJs","QJs","JTs","T9s","44","55","66","77","88","99","TT","JJ","QQ","KK","AA"]}
};
const BOUNTY_BOOST={addLP:["A4s","A3s","A2s","KQo","KTo","QTo","J9s","98s"],addMP:["A5s","KQo","KJo","QJo","T9s","88"]};
function bbBucket(v){ if(v<=12) return '12'; if(v<=20) return '20'; if(v<=30) return '25'; return '40'; }
function pos(){ return 'MP'; } // Platzhalter ‚Äì bei Bedarf echte Positionslogik erg√§nzen
function extend(list,adds){ const s=new Set(list); adds.forEach(a=>s.add(a)); return [...s]; }
function inOpenRange(cmb,ebb,bounty){ const b=bbBucket(ebb), p=pos(); let L=(BASE_RANGES[b]?.[p]||[]); if(bounty){ L=extend(L, p==='LP'?BOUNTY_BOOST.addLP:BOUNTY_BOOST.addMP);} return L.includes(cmb); }
function decide(cmb,effBB,bounty){
 if(!cmb||!effBB) return {a:'WAIT',msg:'Karten/Blinds/Stacks unvollst√§ndig.'};
 if(inOpenRange(cmb,effBB,bounty)){
   const base=effBB<=15?2.0:(effBB<=30?2.2:2.5);
   const mult=bounty?(base+0.2):base;
   return {a:'RAISE',msg:`Open ~${mult.toFixed(1)}√ó BB (eff. ${effBB.toFixed(1)}bb)`};
 }
 if(effBB<=12) return {a:'PUSH',msg:`Short (‚â§12bb) ‚Äì Jam bevorzugt`};
 return {a:'FOLD',msg:`Nicht in Open-Range @ eff. ${bbBucket(effBB)}bb${bounty?' ‚Ä¢ Bounty':''}`};
}

/* ---------- Haupt-Loop ---------- */
async function step(){
 if(running||!stream) return;
 const now=performance.now(); if(now-lastTick<1000) return; lastTick=now; running=true;
 try{
   const T=await iAmOnTurn(); const amTurn = forceTurn.checked ? true : T.turn;
   sTurn.textContent = amTurn ? 'Am Zug ‚úîÔ∏é' : '‚Äì'; logDbg(dbgButtons, T.raw);

   if(!amTurn){ sRec.textContent='‚Äì'; sExp.textContent='Warte auf Buttons‚Ä¶'; return; }

   // OCR lesen
   const c1=await ocrBox(rects.card1,'10'); const c2=await ocrBox(rects.card2,'10');
   logDbg(dbgC1,c1.text); logDbg(dbgC2,c2.text);
   const C1=parseCard(c1.text), C2=parseCard(c2.text); const cmb=combo(C1,C2); sCards.textContent=cmb||`${C1||'?'} ${C2||'?'}`;

   const b =await ocrBox(rects.blinds,'6'); const blinds=parseBlinds(b.text); logDbg(dbgBlinds,b.text);
   const sh=await ocrBox(rects.stackH,'6'); const hero=parseStackAny(sh.text); logDbg(dbgStackH,sh.text);

   const g1=await ocrBox(rects.g1,'6'); const st1=parseStackAny(g1.text); logDbg(dbgStack1,g1.text);
   const g2=await ocrBox(rects.g2,'6'); const st2=parseStackAny(g2.text); logDbg(dbgStack2,g2.text);
   const g3=await ocrBox(rects.g3,'6'); const st3=parseStackAny(g3.text); logDbg(dbgStack3,g3.text);

   // Anzeige Blinds/Hero
   sSB.textContent=(blinds?`${blinds.sb}/${blinds.bb}`:'?')+' | '+(hero?hero.val:'?');

   // in BB umrechnen
   const toBB=(s)=>!s?null:(s.mode==='bb'?s.val:(blinds? s.val/blinds.bb : null));
   const bbHero=toBB(hero), bb1=toBB(st1), bb2=toBB(st2), bb3=toBB(st3);

   // Effektiver Stack (min von Hero & Gegnern)
   const candidates=[bbHero,bb1,bb2,bb3].filter(v=>typeof v==='number'&&isFinite(v)&&v>0);
   const effBB=candidates.length? Math.min(...candidates) : null;
   sEff.textContent = effBB? effBB.toFixed(1) : '‚Äì';

   // Entscheidung
   const d=decide(cmb, effBB, !!bountyToggle.checked);
   sRec.textContent=d.a; sExp.textContent=d.msg;
 }catch(e){ console.error(e); }
 finally{ running=false; }
}
function loop(){ requestAnimationFrame(loop); step(); draw(); }

/* ---------- Init & Buttons ---------- */
btnCal.onclick=()=>{ calib=!calib; badge.textContent='Calib: '+(calib?'ON':'OFF'); badge.classList.toggle('on',calib); draw(); };
btnAuto.onclick=autoROIs;
btnNext.onclick=nextBox;
btnReset.onclick=resetBoxes;
btnCam.onclick=async()=>{ try{
 if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null;}
 const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
 video.srcObject=s; await video.play(); stream=s;
 document.querySelector('.videoWrap').style.aspectRatio=`${video.videoWidth||1080}/${video.videoHeight||1920}`;
 resize();
}catch(e){ alert('Kamera-Fehler: '+e.name+' ‚Äì '+e.message+'\nTipp: iOS > Einstellungen > Edge > Kamera > Erlauben.'); } };

load(); resize(); loop();
</script>
</body>
</html>